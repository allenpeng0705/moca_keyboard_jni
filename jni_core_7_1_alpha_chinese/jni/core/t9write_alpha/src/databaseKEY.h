/*******************************************************************************
;*******************************************************************************
;**                                                                           **
;**                    COPYRIGHT 2010 NUANCE COMMUNICATIONS                   **
;**                                                                           **
;**                NUANCE COMMUNICATIONS PROPRIETARY INFORMATION              **
;**                                                                           **
;**     This software is supplied under the terms of a license agreement      **
;**     or non-disclosure agreement with Nuance Communications and may not    **
;**     be copied or disclosed except in accordance with the terms of that    **
;**     agreement.                                                            **
;**                                                                           **
;*******************************************************************************
;******************************************************************************/


/*
Autogenerated header.
$Revision: 1.5 $
$Date: 2011/02/14 11:41:14 $
$Author: jianchun_meng $
*/

/* file: databaseKEY.h 

   Types and function prototypes for the database
   as it is stored internally for the algorithms.

   When reading the database from an external source, 
   it has to be converted to this format.

*/

#ifndef databaseKEY_h
#define databaseKEY_h

#ifdef DECUMA_MANGLE
#include "mangle.h"
#endif

#include "databaseFormat.h"
#include "databaseKID.h"
#include "decumaString.h"


#define kidHasDiac( pKid ) ( (pKid)->noDiacArcs != 0 )

#define kidGetSumX( pKid )  (( (pKid)->noBaseArcs > 0 ? kidGetBaseKEY(pKid)->sumX: 0 ) + (DECUMA_INT32)( kidHasDiac(pKid) ? kidGetDiacKEY(pKid)->sumX + (DECUMA_INT32)(pKid)->diacKeyXOffset * (pKid)->noDiacArcs * NUMBER_OF_POINTS_IN_ARC : 0) )

#define kidGetSumY( pKid )  (( (pKid)->noBaseArcs > 0 ? kidGetBaseKEY(pKid)->sumY: 0 ) + (DECUMA_INT32)( kidHasDiac(pKid) ? kidGetDiacKEY(pKid)->sumY + (DECUMA_INT32)(pKid)->diacKeyYOffset * (pKid)->noDiacArcs * NUMBER_OF_POINTS_IN_ARC : 0) )

#define kidGetDQSum( pKid )  (( (pKid)->noBaseArcs > 0 ? kidGetBaseKEY(pKid)->dqSum: 0 ) + ( kidHasDiac(pKid) ? kidGetDiacKEY(pKid)->dqSum: 0))

#define kidGetXWidth( pKid )  (kidGetBaseKEY(pKid)->xWidth)

#define kidGetInterleavedSumX( pKid)  (( (pKid)->noBaseArcs > 0 ? kidGetBaseKEY(pKid)->interleavedSumX: 0 ) + (DECUMA_INT32)( kidHasDiac(pKid) ? kidGetDiacKEY(pKid)->interleavedSumX + (DECUMA_INT32)(pKid)->diacKeyXOffset * (pKid)->noDiacArcs * NUMBER_OF_POINTS_IN_INTERLEAVED_ARC: 0)) 

#define kidGetInterleavedSumY( pKid)  (( (pKid)->noBaseArcs > 0 ? kidGetBaseKEY(pKid)->interleavedSumY: 0 ) + (DECUMA_INT32)( kidHasDiac(pKid) ? kidGetDiacKEY(pKid)->interleavedSumY + (DECUMA_INT32)(pKid)->diacKeyYOffset * (pKid)->noDiacArcs * NUMBER_OF_POINTS_IN_INTERLEAVED_ARC :0))

/*#define kidGetLigature( pKid ) ((pKid)->pDB->pLigatureTable[kidGetBaseKEY(pKid)->ligatureNr]) */
/*#define kidGetLigLength( pKid ) ((pKid)->pDB->pLigLengthTable[kidGetBaseKEY(pKid)->ligLengthNr]) */


/*#define kidGetSymmetry( pKid ) (!kidHasDiac(pKid) ? propDBGetSymmetry((pKid)->pDB->pSymmetryTable[kidGetTypeInfo(pKid)->symmetryNr]:( (pKid)->noBaseArcs == 0   ? (pKid)->pDB->pSymmetryTable[kidGetDiacKEY(pKid)->symmetryNr]: (pKid)->pDB->pSymmetryTable[0])) //default setting  */

/*#define kidGetRotation( pKid ) (!kidHasDiac(pKid) ? ((pKid)->pDB->pRotationTable[kidGetTypeInfo(pKid)->rotationNr]):((pKid)->pDB->pRotationTable[0]) ) //default setting */

/*#define kidGetTypeInfo( pKid ) ( kidGetBaseKEY( pKid )->pTypeInfo ) */

/*#define kidGetSymbolInfo( pKid ) ( kidGetTypeInfo(pKid)->pSymbolInfo )  */

#define keyGetDiacriticMaskNr( pKid )  (!kidHasDiac(pKid) ? (kidGetSymbolInfo(pKid)->diacriticMaskNr) : (-1) )

#define databaseGetDiacriticMask( pDB, maskNr, nDiacs ) (pDB->pDiacriticMasks[maskNr][(nDiacs)-1] ) 

#define diacKeyGetSymbolNr( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->diacSymbolNr : -1)

#define diacKeyGetDiacCurveIndex( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->diacCurveIndex : -1)

#define diacKeyGetSymbol( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->diacSymbol : -1)

#define diacKeyGetPlacementMask( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->placementMask : -1)

#define diacKeyPlacementIsAbove( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->placementMask & 0x01 : -1)

#define diacKeyPlacementIsBelow( pKid ) ( kidHasDiac(pKid)? kidGetDiacKEY(pKid)->placementMask & 0x02 : -1)

/*#define symbolInfoGetDiacriticMask(sInfo, nDiacs) ((sInfo)->diacriticMaskNr->strokeMask[(nDiacs)-1]) */


#define keyarcGetX( pkey_arc, pointNr ) ((pkey_arc)[pointNr])
#define keyarcGetY( pkey_arc, pointNr ) ((pkey_arc)[NUMBER_OF_POINTS_IN_ARC+pointNr])

#define keyGetArcOffsetX( kid, arcNr ) ( (arcNr) < (kid)->noBaseArcs ? 0 : (kid)->diacKeyXOffset )
#define keyGetArcOffsetY( kid, arcNr ) ( (arcNr) < (kid)->noBaseArcs ? 0 : (kid)->diacKeyYOffset )

#define keyArcCanBeRotated( arcNr, mask ) ( mask >> (arcNr) & 1 ) /*arcNr 0 is first arc */

#define keyarcGetNoPoints( pkey_arc ) ( NUMBER_OF_POINTS_IN_ARC )

#ifdef __cplusplus
extern "C" {
#endif

DECUMA_HWR_PRIVATE DECUMA_INT32 kidGetInterleavedNorm( const KID * pKid);

DECUMA_HWR_PRIVATE DECUMA_INT32 kidGetQSum( const KID * pKid);

DECUMA_HWR_PRIVATE int kidIsGesture(const KID * pKid, int *pbInstant);

DECUMA_HWR_PRIVATE DIAC_SYMBOL_INFO_PTR kidGetDiacSymbolInfo( const KID * pKid );
DECUMA_HWR_PRIVATE SYMBOL_TYPE_INFO_PTR kidGetTypeInfo( const KID * pKid );
DECUMA_HWR_PRIVATE CATEGORIES_PTR kidGetCategories( const KID * pKid );

DECUMA_HWR_PRIVATE void kidSetBaseKeyPointer(KID * pKid);

DECUMA_HWR_PRIVATE void kidSetDiacKeyPointer(KID * pKid);

DECUMA_HWR_PRIVATE DECUMA_UNICODE_DB_PTR kidGetSymbol( const KID * pKid );

#ifdef _DEBUG
DECUMA_HWR_PRIVATE const DECUMA_UINT8 kidGetArcTimelineDiffMask( const KID * pKid );
#else
#define kidGetArcTimelineDiffMask(pKid) kidGetTypeInfo(pKid)->arcTimelineDiffMask
#endif

/*
This function initializes the KID to the first base KEY in the
static database.
*/
DECUMA_HWR_PRIVATE void kidInitToFirstKeyInStaticDB(STATIC_DB_HEADER_PTR pStaticDB, KID * pKid);

DECUMA_HWR_PRIVATE DECUMA_INT8_DB_PTR kidGetArcPointer( const KID * pKid, int arcNr );

DECUMA_HWR_PRIVATE ARC_ORDER_SET_PTR kidGetArcOrderSetPtr( const KID * pKid );

typedef enum {
	db_certain = 0,
	db_littleuncertain,
	db_quiteUncertain,
	db_veryUncertain
} UNCERTAINTY;

DECUMA_HWR_PRIVATE UNCERTAINTY keySizeUncertainty( const KID * pKid );

DECUMA_HWR_PRIVATE UNCERTAINTY keyPositionUncertainty( const KID * pKid );

DECUMA_HWR_PRIVATE UNCERTAINTY keyShapeUncertainty( const KID * pKid );

/*A mask: bit n = 1 means that arc number n can be rotated */
DECUMA_HWR_PRIVATE DECUMA_UINT8 keyGetArcRotationMask( const KID * pKid );

#ifdef DEBUG_DUMP_SCR_DATA
DECUMA_HWR_PRIVATE void		keyDump    (char *title, const KID kid, int noArcs);
#endif /*DEBUG_DUMP_SCR_DATA */

DECUMA_HWR_PRIVATE void kidGetMinMaxX(const KID * pKid, DECUMA_INT8 * pnMinX, DECUMA_INT8 * pnMaxX);
DECUMA_HWR_PRIVATE void kidGetMinMaxY(const KID * pKid, DECUMA_INT8 * pnMinY, DECUMA_INT8 * pnMaxY);

#ifdef __cplusplus
} /*extern "C" { */
#endif
#endif
