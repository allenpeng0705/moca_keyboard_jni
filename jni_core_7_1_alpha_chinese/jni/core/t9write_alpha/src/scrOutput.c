/*******************************************************************************
;*******************************************************************************
;**                                                                           **
;**                    COPYRIGHT 2010 NUANCE COMMUNICATIONS                   **
;**                                                                           **
;**                NUANCE COMMUNICATIONS PROPRIETARY INFORMATION              **
;**                                                                           **
;**     This software is supplied under the terms of a license agreement      **
;**     or non-disclosure agreement with Nuance Communications and may not    **
;**     be copied or disclosed except in accordance with the terms of that    **
;**     agreement.                                                            **
;**                                                                           **
;*******************************************************************************
;******************************************************************************/


/*
Autogenerated header.
$Revision: 1.5 $
$Date: 2011/02/14 11:41:14 $
$Author: jianchun_meng $
*/

#include "database.h"
#include "databaseKEY.h"
#include "scrOutput.h"
#include "decumaMemory.h"
#include "decumaAssert.h"
#include "decumaString.h"
#include "decumaMath.h"
#include "globalDefs.h"

#ifdef _WIN32
#include <stdio.h>
#endif

#define INIT_DB_INDEX(out) ((out).DBindex.baseKeyIndex = -1)

void outputInit(scrOUTPUT* pOut)
{
	myMemSet(pOut,0, sizeof(*pOut));
	INIT_DB_INDEX(*pOut);
}

void outputInitVector(scrOUTPUT * pOut, int nOut)
{
	int o;
	myMemSet(pOut, 0, sizeof(*pOut) * nOut);
	for(o = 0 ; o < nOut ; o++)
	{
		INIT_DB_INDEX(pOut[0]);
	}
}

#ifdef _DEBUG
int outputSort(scrOUTPUT *p, int nSort)
{
	/* Returns 0 if order didn't change .. */

	DECUMA_UINT8 j, sorted = 0;
	int swapped = 0;
	int newValue, oldValue;
	/*int cutLeftTemp, cutRightTemp; */

	while (!sorted)
	{
		sorted = 1;
		oldValue = p[0].mu + p[0].punish;
		for(j = 1; j < nSort; j++)
		{
			if(!databaseValidKID(p[j].DBindex) || !databaseValidKID(p[j-1].DBindex))
				continue; /* Dont try to sort illegal elements. */

			newValue = p[j].mu + p[j].punish;
			if(newValue < oldValue)
			{
				scrOUTPUT temp = p[j-1];
				p[j-1] = p[j];
				p[j] = temp;

				sorted = 0; /*The pair was not sorted. */
				swapped++;
			}
			else
			{
				oldValue = newValue;
			}
		}
	}
	return swapped;
}
#endif

void outputResetVector(scrOUTPUT * pOut, int nOut)
{
	int i;
	DECUMA_INT16 muMax = MAX_DECUMA_INT16;

	myMemSet(pOut, 0, sizeof(*pOut) * nOut);
	for(i = 0 ; i < nOut ; i++)
	{
		pOut[i].mu = muMax;
		pOut[i].DBindex.baseKeyIndex = -1;
	}
}


TYPE_CONFLICTS_PTR outputGetConflictData(const scrOUTPUT * pOut)
{
	int i, nTypeConflicts;
	DECUMA_UINT16 typeIdx;
	TYPE_CONFLICTS_PTR pTypeConflicts;

	decumaAssert( pOut );
	if ( kidHasDiac(&pOut->DBindex) ) {
		/* This is a combined key (has diacrit). */
		/* At the moment no conflict handling for diac keys */
		return NULL;
	}

	nTypeConflicts = propDBGetTypeConflicts(pOut->DBindex.pPropDB,
		&pTypeConflicts);

	typeIdx = kidGetBaseKEY(&pOut->DBindex)->typeIdx;

	/* Lets check if the new output has any conflicts. */
	for ( i = 0; i < nTypeConflicts ; i++, pTypeConflicts++) {
		if ( pTypeConflicts->typeIdx == typeIdx ) {
			/* We found a conflict */
			return pTypeConflicts;
		}
	}

	/* We didn't find any conflicts. */
	return NULL;
}

/* Returns non-zero if output 1 has a conflict with output 2, */
/* i.e. if output #2 shall be prioritized? */
/* pOut1Conflict shall point to a TYPE_CONFLICTS struct for output #1 */
/* pOut2 shall point to output #2 */
int outputConflict(TYPE_CONFLICTS_PTR pOut1Conflict,
						  const scrOUTPUT * pOut2)
{
	decumaAssert( pOut2 );
	if ( pOut1Conflict )
	{
		int i;
		DECUMA_UINT16_DB_PTR pConflictTypeIdxs;
		KEY_PTR pKey = kidGetBaseKEY(&pOut2->DBindex);
		DECUMA_UINT16 typeIdx;

		decumaAssert( pKey );
		typeIdx = pKey->typeIdx;

		/*NOTE this special hack, relies on DB format */
		pConflictTypeIdxs = pOut1Conflict->conflicts;

		for ( i = 0; i < pOut1Conflict->nConflicts; i++) {
			/*if ( pConflictTypeIdxs[i] == pKey->typeIdx ) { */
			if ( pConflictTypeIdxs[i] == typeIdx ) {
				/* Output #1 has a conflict to output #2 */
				return 1;
			}
		}
	}

	return 0; /* No conflict */
}


void scrOutputCreateSpecial(scrOUTPUT * pOutput, const SCR_CURVE * pCurve, DECUMA_INT16 mu, KID * pKid)
{
	/* Creates a scrOUTPUT with the proximity mu and the Key identifier (KID) pKid.. */

	int i;
	DECUMA_INT8_DB_PTR ppArcOrders[1];
	int nArcOrders;

	decumaAssert( pKid );

	outputInit(pOutput);
	pOutput->DBindex = *pKid;
	nArcOrders = kidGetArcOrders(pKid, ppArcOrders, sizeof(ppArcOrders)/sizeof(ppArcOrders[0]));

	decumaAssert(nArcOrders == 1);


	for (i=0; i<pCurve->noArcs; i++)
		pOutput->arcOrder[i] = ppArcOrders[0][i];

	pOutput->simTransf.symPoint.x = ( curveGetSumX(pCurve) *
		SIM_TRANSF_ROUNDING_FACTOR ) / curveGetMass(pCurve);

	pOutput->simTransf.symPoint.y = ( curveGetSumY(pCurve) *
		SIM_TRANSF_ROUNDING_FACTOR ) / curveGetMass(pCurve);

	pOutput->simTransf.delta.x = ( kidGetSumX(pKid) *
		SIM_TRANSF_ROUNDING_FACTOR ) / curveGetMass(pCurve);

	pOutput->simTransf.delta.y = ( kidGetSumY(pKid) *
		SIM_TRANSF_ROUNDING_FACTOR ) / curveGetMass(pCurve);

	pOutput->simTransf.scale = SIM_TRANSF_SCALE_FACTOR;

	pOutput->mu = mu;
	pOutput->symbol = kidGetSymbol(pKid);
	pOutput->arcTimelineDiffMask = kidGetArcTimelineDiffMask(pKid);
} /* scrOutputCreateSpecial() */

#ifdef DEBUG_DUMP_SCR_DATA
/* Writes the data in the struct scrOUTPUT to a file.  */
void scrOutputDump(FILE * pf, scrOUTPUT * pOutput)
{
	int i;
	KID * pK = &pOutput->DBindex;

	fprintf(pf, "\n*** scrOUTPUT start ***\n");
	fprintf(pf, "Symbol         = %s\n", pOutput->symbol);
	fprintf(pf, "DBindex        = %d %d %d %d %d %d\n", pK->noBaseArcs,
		pK->baseKeyIndex, pK->noDiacArcs, pK->diacKeyIndex,
		pK->diacKeyXOffset, pK->diacKeyYOffset);
	fprintf(pf, "Proximity      = %d\n", pOutput->mu);
	fprintf(pf, "Punish         = %d\n", pOutput->punish);
	/*simTransfDump(pf, &pOutput->simTransf); */
	fprintf(pf, "nCutLeft       = %d\n", pOutput->nCutLeft);
	fprintf(pf, "nCutRight      = %d\n", pOutput->nCutRight);
	fprintf(pf, "arcTimelineDiffMask = %d\n", pOutput->arcTimelineDiffMask);

	fprintf(pf, "arc order      = ");
	for ( i = 0;
	      i < pOutput->DBindex.noBaseArcs + pOutput->DBindex.noDiacArcs;
		  i++) {
		fprintf(pf, "%d ", pOutput->arcOrder[i]);
	}
	fprintf(pf, "\n");

	fprintf(pf, "outSymbol      = ");
	switch ( pOutput->outSymbol ) {
		case original :
			fprintf(pf, "original\n");
			break;
		case alternative :
			fprintf(pf, "alternative\n");
			break;
		case both :
			fprintf(pf, "both\n");
			break;
		default :
			fprintf(pf, "unknown!!\n");
	}
	fprintf(pf, "***  scrOUTPUT end  ***\n");
} /*scrOutputDump() */
#endif /*DEBUG_DUMP_SCR_DATA */
