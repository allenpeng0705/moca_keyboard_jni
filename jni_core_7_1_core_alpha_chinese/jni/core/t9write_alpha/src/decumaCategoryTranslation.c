/*******************************************************************************
;*******************************************************************************
;**                                                                           **
;**                    COPYRIGHT 2010 NUANCE COMMUNICATIONS                   **
;**                                                                           **
;**                NUANCE COMMUNICATIONS PROPRIETARY INFORMATION              **
;**                                                                           **
;**     This software is supplied under the terms of a license agreement      **
;**     or non-disclosure agreement with Nuance Communications and may not    **
;**     be copied or disclosed except in accordance with the terms of that    **
;**     agreement.                                                            **
;**                                                                           **
;*******************************************************************************
;******************************************************************************/

#include <stddef.h> /* Definition of NULL */
#include "decumaCategoryTranslation.h"

#include "decumaCatCombDataType.h"
#include "decumaLanguages.h"
#include "decumaSymbolCategories.h"
#include "decumaCategoryCombinationData.h"  /* File generated by Matlab */
#include "decumaStatus.h"  
#include "decumaAssert.h"  
#include "decumaExtractLangCatTables.h"

#define NUMBER_OF_CATEGORIES_IN_DB 64

/*///////////////////////////////////////////// */

static int getAtoms( const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs,
	DECUMA_UINT32 combination, DECUMA_UINT32 * pAtoms, 
	DECUMA_UINT8 nMaxAtoms);
	

/* A return value > 0 indicates unsupported categories were found */
static int translateToCatMasks(DECUMA_UINT32 *pCategories, DECUMA_UINT8 nCategories, 
	const DECUMA_UINT32 DECUMA_DB_STORAGE * pCatIdMap, const DECUMA_UINT32 DECUMA_DB_STORAGE * pUdmCatIdMap,
	const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs,
	CATEGORY_MASK * pCatMask, CATEGORY_MASK * pUDMCatMask);
	

static int addUnfamiliarAtoms(DECUMA_UINT32 * pCategories, DECUMA_UINT8 nCategories,
	DECUMA_UINT32 * pCatIdMap, const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs);
	
/*///////////////////////////////////////////// */


int isAtomInSymbolCategory( DECUMA_UINT32 atomicCategory,
					 DECUMA_UINT32 combinationCategory)
{
	DECUMA_UINT32 atomicCategories[MAX_ATOMS_IN_COMBINATION];
	int nAtoms;
	int i;

	if (combinationCategory == atomicCategory) return 1;
	
	nAtoms = getAtoms(&decumaCombinationCategories[0], 
		sizeof(decumaCombinationCategories)/sizeof(decumaCombinationCategories[0]),
		combinationCategory, atomicCategories, 
		sizeof(atomicCategories)/sizeof(atomicCategories[0]));

	for (i=0; i<nAtoms; i++)
	{
		if (atomicCategories[i]==atomicCategory)
		{
			return 1;
		}
	}

	return 0;
}


int getAtomicCategories( DECUMA_UINT32 combinationCategory, DECUMA_UINT32 * pAtomicCategories, 
	DECUMA_UINT8 nMaxAtomicCategories)
{
	return getAtoms( &decumaCombinationCategories[0], 
		sizeof(decumaCombinationCategories)/sizeof(decumaCombinationCategories[0]),
		combinationCategory, pAtomicCategories, nMaxAtomicCategories);
}

int getAtomicLanguages( DECUMA_UINT32 combinationLanguage, DECUMA_UINT32 * pAtomicLanguages, 
	DECUMA_UINT8 nMaxAtomicLanguages)
{
	return getAtoms( &decumaCombinationCategories[0], 
		sizeof(decumaCombinationLanguages)/sizeof(decumaCombinationLanguages[0]),
		combinationLanguage, pAtomicLanguages, nMaxAtomicLanguages);
}

DECUMA_STATUS checkCharacterSetValidity(const DECUMA_CHARACTER_SET * pCharacterSet,
	int bAcceptReserved)
{
	int i;

	decumaAssert(pCharacterSet);
	if (!pCharacterSet) return decumaNullPointer;

	if (!pCharacterSet->pSymbolCategories && pCharacterSet->nSymbolCategories>0) 
		return decumaNullPointer;

	if (!pCharacterSet->pLanguages && pCharacterSet->nLanguages>0) 
		return decumaNullPointer;

	for (i=0; i<pCharacterSet->nSymbolCategories; i++)
	{
		DECUMA_UINT32 cat = pCharacterSet->pSymbolCategories[i];

		if (!(isStandardSymbolCategory(cat) ||
			 (bAcceptReserved && (cat >= DECUMA_CATEGORY_RESERVED_START && cat <= DECUMA_CATEGORY_RESERVED_END)) ||
			 (cat >= DECUMA_CATEGORY_USER_DEFINED_START && cat <= DECUMA_CATEGORY_USER_DEFINED_END)))
		{
			return decumaInvalidCategory;
		}
	}
		
	for (i=0; i<pCharacterSet->nLanguages; i++)
	{
		DECUMA_UINT32 lang = pCharacterSet->pLanguages[i];
		if (!(isStandardLanguage(lang) ||
			 (bAcceptReserved && (lang >= DECUMA_LANG_RESERVED_START && lang <= DECUMA_LANG_RESERVED_END)) ||
			 (lang >= DECUMA_LANG_USER_DEFINED_START && lang <= DECUMA_LANG_USER_DEFINED_END)))
		{
			return decumaInvalidLanguage;
		}
	}
	return decumaNoError;
}


int isStandardSymbolCategory( DECUMA_UINT32 cat)
{
	unsigned int i;
	for (i=0; i<sizeof(decumaAllSymbolCategories)/sizeof(decumaAllSymbolCategories[0]); i++)
	{
		if (decumaAllSymbolCategories[i]==cat)
		{
			return 1;
		}
	}
	return 0;
}

int isStandardLanguage( DECUMA_UINT32 lang)
{
	unsigned int i;
	for (i=0; i<sizeof(decumaAllLanguages)/sizeof(decumaAllLanguages[0]); i++)
	{
		if (decumaAllLanguages[i]==lang)
		{
			return 1;
		}
	}
	return 0;
}


DECUMA_STATUS translateToCategoryStructs(const DECUMA_CHARACTER_SET * pCharacterSet, 
	CATEGORY_TABLE_PTR pCatTable, CATEGORY_TABLE_PTR pCatTableDb2, 
	CATEGORY * pCat, CATEGORY * pCatDb2)
{
  /*CAT_TABLE_PTR pCT = (CAT_TABLE_PTR) pCatTable; */
  /*CAT_TABLE_PTR pCTDb2 = (CAT_TABLE_PTR) pCatTableDb2; */

	int catError = translateToCatMasks(pCharacterSet->pSymbolCategories,
					   pCharacterSet->nSymbolCategories, 
					   pCatTable ? getCategoryIds(pCatTable) : NULL,
					   pCatTableDb2 ? getCategoryIds(pCatTableDb2) :  NULL,
		decumaCombinationCategories, sizeof(decumaCombinationCategories)/sizeof(decumaCombinationCategories[0]),
		pCat ? (&pCat->symbolCat) : NULL, pCatDb2? (&pCatDb2->symbolCat) : NULL);
	
	int langError = translateToCatMasks(pCharacterSet->pLanguages,
					    pCharacterSet->nLanguages, 
					    pCatTable ? getLanguageIds(pCatTable) : NULL,
					    pCatTableDb2 ? getLanguageIds(pCatTableDb2) : NULL,
		decumaCombinationLanguages, sizeof(decumaCombinationLanguages)/sizeof(decumaCombinationLanguages[0]),
		pCat? (&pCat->languageCat) : NULL, pCatDb2? (&pCatDb2->languageCat) : NULL);
	
	if (catError>0) return decumaUnsupportedSymbolCategory;
	if (langError>0) return decumaUnsupportedLanguage;
	
	return decumaNoError;
}

DECUMA_STATUS addUnfamiliarAtomicCategories(const DECUMA_CHARACTER_SET * pCharacterSet, 
	DECUMA_UINT32 * pSymbolCatIdMap, DECUMA_UINT32 * pLanguageIdMap)
{
	int error;
	
	error = addUnfamiliarAtoms(pCharacterSet->pSymbolCategories, pCharacterSet->nSymbolCategories,
		pSymbolCatIdMap, decumaCombinationCategories, 
		sizeof(decumaCombinationCategories)/sizeof(decumaCombinationCategories[0]));

	if (error) return decumaTooManyCategoriesForTable;

	error = addUnfamiliarAtoms(pCharacterSet->pLanguages, pCharacterSet->nLanguages,
		pLanguageIdMap, decumaCombinationLanguages, 
		sizeof(decumaCombinationLanguages)/sizeof(decumaCombinationLanguages[0]));

	if (error) return decumaTooManyLanguagesForTable;

	return decumaNoError;
}

/*///////////////////////////////////////////// */

static int addUnfamiliarAtoms(DECUMA_UINT32 * pCategories, DECUMA_UINT8 nCategories,
	DECUMA_UINT32 * pCatIdMap, const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs)
{
	int i;
	for (i=0; i<nCategories; i++)
	{
		DECUMA_UINT32 atoms[MAX_ATOMS_IN_COMBINATION];
		DECUMA_UINT32 currentCategory = pCategories[i];
		int j,nAtoms;

		nAtoms = getAtoms( pCatCombPairs, 
			nCatCombPairs, currentCategory, &atoms[0], 
			sizeof(atoms)/sizeof(atoms[0]));

		if (nAtoms == 0)
		{
			nAtoms=1;
			atoms[0] = currentCategory;
		}
		
		for (j=0; j<nAtoms; j++)
		{
			int k,bFound =0;
			for (k=0; k<NUMBER_OF_CATEGORIES_IN_DB && pCatIdMap[k]!=0; k++)
			{
				if (pCatIdMap[k] == atoms[j])
				{
					bFound = 1;
					break;
				}
			}
			if (!bFound)
			{
				/*Category does not exist in catMap */
				if (k>=NUMBER_OF_CATEGORIES_IN_DB)
				{
					return 1;
				}
				else
				{
					decumaAssert(pCatIdMap[k]==0);
					pCatIdMap[k]=atoms[j];
				}
			}
		}
	}
	return 0;
}
	

static int getAtoms( const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs,
	DECUMA_UINT32 combination, DECUMA_UINT32 * pAtoms, 
	DECUMA_UINT8 nMaxAtoms)
{
	int i;
	int nAtoms=0;
	
	decumaAssert(pCatCombPairs);
	decumaAssert(pAtoms);
	
	for (	i=0; 
			i<nCatCombPairs && nAtoms<nMaxAtoms; 
			i++)
	{
		if (pCatCombPairs[i].combinationID == combination)
		{
			pAtoms[nAtoms++] = pCatCombPairs[i].atomicID;
		}
	}
	return nAtoms;
}

static int translateToCatMasks(DECUMA_UINT32 *pCategories, DECUMA_UINT8 nCategories,
	const DECUMA_UINT32 DECUMA_DB_STORAGE * pCatIdMap, const DECUMA_UINT32 DECUMA_DB_STORAGE* pCatIdMapDb2,
	const CATEGORY_COMB_PAIR * pCatCombPairs, int nCatCombPairs,
	CATEGORY_MASK * pCatMask, CATEGORY_MASK * pCatMaskDb2)
{
	int i;
	int retVal=0;
	if (pCatMask) CATEGORY_MASK_RESET(*pCatMask);
	if (pCatMaskDb2) CATEGORY_MASK_RESET(*pCatMaskDb2);
	
	for (i=0; i<nCategories; i++)
	{
		int j;
		DECUMA_UINT32 atomicCategories[MAX_ATOMS_IN_COMBINATION];
		int nAtoms;
		
		
		nAtoms = getAtoms(pCatCombPairs, nCatCombPairs, pCategories[i], 
			atomicCategories, sizeof(atomicCategories)/sizeof(atomicCategories[0]));

		if (nAtoms==0)
		{
			/*This was not a combined category - then it is atomic */
			atomicCategories[0] = pCategories[i];
			nAtoms = 1;
		}
		for (j=0; j<nAtoms; j++)
		{
			CATEGORY_MASK nCatBit,nCatBitDb2;
			int bSupportedCategory = 0;

			CATEGORY_MASK_RESET(nCatBit);
			CATEGORY_MASK_RESET(nCatBitDb2);
			
			if (pCatIdMap)
			{
				translateIdToCatBit(pCatIdMap,atomicCategories[j],&nCatBit);
				
				if (!CATEGORY_MASK_IS_EMPTY(nCatBit))
				{
					bSupportedCategory = 1;
				}
				if (pCatMask) CATEGORY_MASK_OR(*pCatMask,*pCatMask,nCatBit);
			}

			if (pCatIdMapDb2)
			{
				translateIdToCatBit(pCatIdMapDb2,atomicCategories[j],&nCatBitDb2);
				
				if (!CATEGORY_MASK_IS_EMPTY(nCatBitDb2))
				{
					bSupportedCategory = 1;
				}
				if (pCatMaskDb2) CATEGORY_MASK_OR(*pCatMaskDb2,*pCatMaskDb2,nCatBit);
			}

			if (!bSupportedCategory)
			{
				/*Not supported in any of the databases */
				retVal++;
			}
		}
	}
	return retVal;
}

void translateIdToCatBit(const DECUMA_UINT32 DECUMA_DB_STORAGE * pCatIdMap, DECUMA_UINT32 id, CATEGORY_MASK * pCatMask)
{
	CATEGORY_MASK_RESET(*pCatMask);
	
	if (id==0) 
	{
		return;
	}
	else
	{

		int i;
		const int nBits = sizeof(CATEGORY_MASK)*8; /*The number of bits in a CATEGORY_MASK */
		CATEGORY_MASK tmpMask;
		
		CATEGORY_MASK_SET_ONLY_FIRST_BIT(tmpMask);
		
		for (i=0; i<nBits; i++)
		{
			if (pCatIdMap[i] == id)
			{
				CATEGORY_MASK_COPY(*pCatMask,tmpMask);
				return;
			}
			CATEGORY_MASK_SHIFT_1_LEFT(tmpMask);
		}
	}
}
