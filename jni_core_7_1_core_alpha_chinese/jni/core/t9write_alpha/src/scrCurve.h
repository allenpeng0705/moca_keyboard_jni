/*******************************************************************************
;*******************************************************************************
;**                                                                           **
;**                    COPYRIGHT 2010 NUANCE COMMUNICATIONS                   **
;**                                                                           **
;**                NUANCE COMMUNICATIONS PROPRIETARY INFORMATION              **
;**                                                                           **
;**     This software is supplied under the terms of a license agreement      **
;**     or non-disclosure agreement with Nuance Communications and may not    **
;**     be copied or disclosed except in accordance with the terms of that    **
;**     agreement.                                                            **
;**                                                                           **
;*******************************************************************************
;******************************************************************************/


/*
Autogenerated header.
$Revision: 1.5 $
$Date: 2011/02/14 11:41:14 $
$Author: jianchun_meng $
*/
#ifndef srcCurve_h
#define srcCurve_h

#ifdef DECUMA_MANGLE
#include "mangle.h"
#endif

#include "scrTargetLimits.h"
#include "databaseFormat.h"
#include "decumaMemory.h"
#include "decumaBasicTypes.h"

#define ACCURACY_IN_INTERPOLATE 128

typedef struct _tagArc{

	/* Unweighted feature vectors (fv) */
	DECUMA_INT16 x[NUMBER_OF_POINTS_IN_ARC]; /* alpha_x * x_orig */
	DECUMA_INT16 y[NUMBER_OF_POINTS_IN_ARC]; /* alpha_y * y_orig */
	DECUMA_INT16 dx[NUMBER_OF_POINTS_IN_ARC]; /* alpha_dx * dx_orig */
	DECUMA_INT16 dy[NUMBER_OF_POINTS_IN_ARC]; /* alpha_dy * dy_orig */

	/* Unweighted feature vector sum (sfv) */
	DECUMA_INT32 sum_x; /* Sum( x ) */
	DECUMA_INT32 sum_y; /* Sum( y ) */
	DECUMA_INT32 sum_dx; /* Sum( dx ) */
	DECUMA_INT32 sum_dy; /* Sum( dy ) */
	DECUMA_INT32 sum_abs_dx; /* Sum( dx ) */
	DECUMA_INT32 sum_abs_dy; /* Sum( dy ) */

	/* Unweighted feature vector norms (sfv2) */
	DECUMA_UINT32 sum_x2; /* Sum( x^2 ) */
	DECUMA_UINT32 sum_y2; /* Sum( y^2 ) */
	DECUMA_UINT32 sum_dx2; /* Sum( dx^2 ) */
	DECUMA_UINT32 sum_dy2; /* Sum( dy^2 ) */

	int mass; /* Length of feature vectors */

	/* Feature weights (fw) */
	/* Weighted feature vectors (fv_hat) are obtain as: */
	/* */
	/*  fv_hat = fw * f, fv = unweighted feature vector */
	/* */
	/* NOTE: alpha_f = fw * 8, for precision. */
	/* */
	/* The feature weights should be applied for distance calculations. */

	DECUMA_INT32 alpha_x;
	DECUMA_INT32 alpha_y;
	DECUMA_INT32 alpha_dx;
	DECUMA_INT32 alpha_dy;

	DECUMA_UINT32 nUserData;
	DECUMA_UINT8 min_x_index; /* Index to point with min x value. */
	DECUMA_UINT8 max_x_index; /* Index to point with max x value. */
	DECUMA_UINT8 min_y_index; /* Index to point with min y value. */
	DECUMA_UINT8 max_y_index; /* Index to point with max y value. */
} SCR_ARC;

typedef struct _tagscrCurve{
	SCR_ARC * Arcs[MAX_NUMBER_OF_ARCS_IN_CURVE];
	int arcTimelineDiff[MAX_NUMBER_OF_ARCS_IN_CURVE-1];
	/* These two represent the actual looks of the curve. */
	int noArcs;	/* 0 if not used. */

	/* ... and by using these two parameters (alpha and measure id) ... */
	int measure_id;
	
	/* ... one can precalculate the folowing values. */
	DECUMA_INT32 sum_x; /* Sum( x ) */
	DECUMA_INT32 sum_y; /* Sum( y ) */
	DECUMA_INT32 sum_dx; /* Sum( dx ) */
	DECUMA_INT32 sum_dy; /* Sum( dy ) */
	int mass;
	float norm;	/* mass * Sum( x^2 + y^2 + alpha * dx^2 + alpha * dy^2 ) - Sum( x )^2 - Sum( y )^2 */

	/* Offset to origo and downscale before feature calculation in order to avoid overflow */
	/* Store offset and downscale used in order to adjust e.g. baseline and helpline accordingly */
	DECUMA_INT16 offset_x;
	DECUMA_INT16 offset_y;
	DECUMA_INT8 right_shift;

} SCR_CURVE;

typedef struct _tagscrCurveProp{
	DECUMA_INT16 min_x;
	DECUMA_INT16 max_x;
	DECUMA_INT16 min_y;
	DECUMA_INT16 max_y;

	DECUMA_INT16 base_min_x;
	DECUMA_INT16 base_max_x;
	DECUMA_INT16 base_min_y;
	DECUMA_INT16 base_max_y;

	DECUMA_INT16 offset_x;
	DECUMA_INT16 offset_y;
	DECUMA_INT8 right_shift;

	DECUMA_INT8 noArcs;
	DECUMA_INT8 noBaseArcs;

	DECUMA_INT32 mass;
	float norm;

} SCR_CURVE_PROP;

#define arcInit(pArc) ( myMemSet(pArc,0,sizeof(*pArc)) )

#define arcGetMinX( pArc ) ( pArc->x[pArc->min_x_index] )
#define arcGetMaxX( pArc ) ( pArc->x[pArc->max_x_index] )
#define arcGetMinY( pArc ) ( pArc->y[pArc->min_y_index] )
#define arcGetMaxY( pArc ) ( pArc->y[pArc->max_y_index] )

#define arcGetSumX( pArc ) ( pArc->sum_x )
#define arcGetSumY( pArc ) ( pArc->sum_y )


#define arcGetSumDX( pArc ) (pArc->sum_dx)
#define arcGetSumDY( pArc ) (pArc->sum_dy)
#define arcGetSumAbsDX( pArc ) (pArc->sum_abs_dx)
#define arcGetSumAbsDY( pArc ) (pArc->sum_abs_dy)
#define arcGetSumX2( pArc ) (pArc->sum_x2)
#define arcGetSumY2( pArc ) (pArc->sum_y2)
#define arcGetSumDX2( pArc ) (pArc->sum_dx2)
#define arcGetSumDY2( pArc ) (pArc->sum_dy2)

#define arcGetMeanX( pArc ) ( pArc->sum_x / NUMBER_OF_POINTS_IN_ARC )
#define arcGetMeanY( pArc ) ( pArc->sum_y / NUMBER_OF_POINTS_IN_ARC )

#define arcGetIndexToMinX( pArc ) ( pArc->min_x_index )
#define arcGetIndexToMaxX( pArc ) ( pArc->max_x_index )
#define arcGetIndexToMinY( pArc ) ( pArc->min_y_index )
#define arcGetIndexToMaxY( pArc ) ( pArc->max_y_index )

#define arcGetLength( pArc ) ( sizeof(pArc->x ) / sizeof( pArc->x[0] ) )

#define curveInit( pCurve ) ( myMemSet(pCurve,0,sizeof(*pCurve)) )

#define curveGetX( pcurve, narc, npt ) (pcurve->Arcs[narc]->x[npt])
#define curveGetY( pcurve, narc, npt ) (pcurve->Arcs[narc]->y[npt])
#define curveGetDX( pcurve, narc, npt ) (pcurve->Arcs[narc]->dx[npt])
#define curveGetDY( pcurve, narc, npt ) (pcurve->Arcs[narc]->dy[npt])

#define curveGetXmu curveGetX
#define curveGetYmu curveGetY
#define curveGetArcLength( pcurve, narc ) ( sizeof(pcurve->Arcs[narc]->x ) / sizeof(pcurve->Arcs[narc]->x [0]))
#define curveGetNoArcs( pcurve ) ( pcurve->noArcs )

#define curveGetSumX( pcurve ) (pcurve->sum_x)
#define curveGetSumY( pcurve ) (pcurve->sum_y)
#define curveGetMass( pcurve ) (pcurve->mass)

#ifdef __cplusplus
extern "C" {
#endif


DECUMA_HWR_PRIVATE void curveCopy(SCR_CURVE* pTarget,  const SCR_CURVE * pSource);

DECUMA_HWR_PRIVATE SCR_CURVE *curveCreateFromDatabase(short nArcs, short index);

#ifdef DEBUG_DUMP_SCR_DATA
#include <stdio.h>
/* Writes the data in the struct CURVE to a file. */
DECUMA_HWR_PRIVATE void curveDataDump(FILE * pf, const SCR_CURVE * pC);
DECUMA_HWR_PRIVATE void curveDump    (char *title, const SCR_CURVE *p);
#endif /*DEBUG_DUMP_SCR_DATA */


DECUMA_HWR_PRIVATE int   curveSize    (SCR_CURVE *p);
DECUMA_HWR_PRIVATE void  curveDerivate(SCR_CURVE * pCurve);
DECUMA_HWR_PRIVATE int   curveCompare (short index, SCR_CURVE *a, SCR_CURVE *b);
DECUMA_HWR_PRIVATE short curveSlope   (SCR_CURVE *p, short beg, short end);
DECUMA_HWR_PRIVATE void  curvePlot    (SCR_CURVE *p, int nr);
DECUMA_HWR_PRIVATE void  curveSmooth(SCR_CURVE * pCurve);

/*
	Precalculates x_mu, xd and some other stuff.
*/
DECUMA_HWR_PRIVATE int curveGetTotalLength(const SCR_CURVE * pCurve);

/**
calculates some interesting stuff in a SCR_ARC object based on the nAlpha and the pbIncludeArray mask
pbIncludePointAccToMeasureId - Points to a 1 or 0 for each point of the arc, saying if the point should be included
                               in the calculations or not. (Originating from a measure id filtering).
*/
DECUMA_HWR_PRIVATE void arcPrecalculate(SCR_ARC * pTargetArc, const DECUMA_INT16 * pbIncludePointAccToMeasureId);

/*
Calculates the extent of a curve, The first nArcs in the curve are used to calculate the min and max.
*/
DECUMA_HWR_PRIVATE void curveMinMaxCalculate(const SCR_CURVE * pCurve, int nArcs, DECUMA_INT16 * pStoreXMin, DECUMA_INT16 * pStoreXMax, DECUMA_INT16 * pStoreYMin, DECUMA_INT16 * pStoreYMax);

/*
Calculates the mean of the arcs nStartArc up to nStopArc in the curve pCurve.
*/
DECUMA_HWR_PRIVATE void curveMeanCalculate(const SCR_CURVE * pCurve, int nStartArc, int nStopArc,
		DECUMA_INT16 * pStoreXMean, DECUMA_INT16 * pStoreYMean);

/**
calculates some interesting stuff in a SCR_CURVE object, using the data from its attached ARCs
*/
DECUMA_HWR_PRIVATE void preCalculateCurveFromArcData(SCR_CURVE  * pTargetCurve, int nMeasureID);

/**
Recomputes the coordinates. First it moves it in X and Y by adding nOffset?, and then it scales down
the coordinate by right shifting with nRightShift
*/
DECUMA_HWR_PRIVATE void arcApplyScale(SCR_ARC * pMap, DECUMA_INT32 nOffsetX, DECUMA_INT32 nOffsetY, int nRightShift);

/*
Stretches or contracts a curve, within the 32 points.
*/
DECUMA_HWR_PRIVATE void InterpolateArc(SCR_ARC *target, const SCR_ARC *source, int start, int stop);

/*
Computes norms etc. for the curve.
*/
DECUMA_HWR_PRIVATE void buildCurveMutation(SCR_CURVE * psi, const int measureId, const DECUMA_INT8 * arcOrder);

DECUMA_HWR_PRIVATE void curveGetProp(const SCR_CURVE * pCurve, SCR_CURVE_PROP * pCurveProp, int nBaseArcs);

#ifdef __cplusplus
} /*extern "C" { */
#endif

#endif
